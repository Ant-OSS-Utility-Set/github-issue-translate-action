import * as core from '@actions/core'
import * as github from '@actions/github'
import {Md5} from 'ts-md5'

import {createIssueComment, updateIssue, translate} from './utils'
import getModel from './modes'
import {translateText} from './utils/translate'

const TRANSLATE_TITLE_DIVING = `||`
const ORIGINAL_MD5_PREFIX = `<!--MD5:`
const ORIGINAL_MD5_POSTFIX = `:MD5-->`
const ORIGIN_CONTENT_PREFIX = `<details><summary>åŸæ–‡</summary>`
const ORIGIN_CONTENT_POSTFIX = `</details>`
// const TRANSLATE_DIVIDING_LINE = `<!--This is a translation content dividing line, the content below is generated by machine, please do not modify the content below-->`
//. ğŸ‘¯ğŸ‘­ğŸ»ğŸ§‘â€ğŸ¤â€ğŸ§‘ğŸ‘«ğŸ§‘ğŸ¿â€ğŸ¤â€ğŸ§‘ğŸ»ğŸ‘©ğŸ¾â€ğŸ¤â€ğŸ‘¨ğŸ¿ğŸ‘¬ğŸ¿
const DEFAULT_BOT_MESSAGE = `Github Action Bot detected the issue body's language is not English, translate it automatically`
const DEFAULT_BOT_TOKEN = process.env.GITHUB_TOKEN

async function main(): Promise<void> {
  // core.info(JSON.stringify(github.context))

  const isModifyTitle = core.getInput('IS_MODIFY_TITLE')
  const shouldAppendContent = core.getInput('APPEND_TRANSLATION')
  const botNote = DEFAULT_BOT_MESSAGE
  // ignore when bot comment issue himself
  const botToken = DEFAULT_BOT_TOKEN
  if (!botToken) {
    return core.info(`GITHUB_TOKEN is requried!`)
  }

  const model = getModel()
  if (!model) {
    return
  }

  const {match, title, body, update} = model
  if (!match) {
    return
  }
  if (typeof body == 'undefined') {
    return
  }

  const octokit = github.getOctokit(botToken)
  const originTitle = title?.split(TRANSLATE_TITLE_DIVING)?.[0]
  // @ts-ignoreè§£æå‡ºæ¥åŸå§‹æ•°æ®,test

  let originComment = body
  if (body.indexOf(ORIGINAL_MD5_PREFIX) > -1) {
    originComment = body.slice(
      body.indexOf(ORIGIN_CONTENT_PREFIX) + ORIGIN_CONTENT_PREFIX.length,
      body.indexOf(ORIGIN_CONTENT_POSTFIX)
    )
    console.log(
      'bodyå†…å®¹ï¼š' +
        body +
        ';startindex:' +
        body.indexOf(ORIGIN_CONTENT_PREFIX) +
        ORIGIN_CONTENT_PREFIX.length +
        ';endindex:' +
        body.indexOf(ORIGIN_CONTENT_POSTFIX)
    )
  }

  const startIndex = body.indexOf(ORIGINAL_MD5_PREFIX)

  const titleContentOrigin = translateText.stringify(originComment, originTitle)
  core.info('åŸå§‹æ ‡é¢˜ï¼š' + originTitle)
  core.info('åŸå§‹å†…å®¹ï¼š' + originComment)
  let newMd5 = Md5.hashStr(titleContentOrigin)
  const translateOrigin_MD5 =
    ORIGINAL_MD5_PREFIX + newMd5 + ORIGINAL_MD5_POSTFIX
  if (startIndex > -1) {
    core.info('æ¯”è¾ƒmd5å¼€å§‹ï¼š')
    //md5
    const startIndex = body.indexOf(ORIGINAL_MD5_PREFIX)
    const endIndex = body.indexOf(ORIGINAL_MD5_POSTFIX)
    const originalMd5 = body.slice(
      startIndex + ORIGINAL_MD5_PREFIX.length,
      endIndex
    )

    core.info('æ—§çš„åŸæ–‡md5:' + originalMd5)
    core.info('æ–°çš„åŸæ–‡md5:' + newMd5)
    if (originalMd5 === newMd5) {
      core.info('åŸæ–‡ä¸å˜ï¼Œä¸éœ€è¦edit')
      return
    } else {
      core.info('2ä¸ªmd5ä¸ä¸€è‡´ï¼Œéœ€è¦é‡æ–°ç¿»è¯‘æäº¤ï¼')
    }

    //md5 end
  }

  // translate issue comment body to english
  const translateTmp = await translate(titleContentOrigin)
  if (!translateTmp || translateTmp == titleContentOrigin) {
    return core.warning('The translateBody is null or same, ignore return.')
  }

  let [translateTitle, translateComment] = translateText.parse(translateTmp)

  core.info('ç¿»è¯‘æ ‡é¢˜ï¼š' + translateTitle)
  core.info('ç¿»è¯‘å†…å®¹ï¼š' + translateComment)
  if (shouldAppendContent) {
    let title = ''
    if (translateTitle && originTitle !== translateTitle) {
      title = [originTitle, translateTitle].join(TRANSLATE_TITLE_DIVING)
    }

    let body = ''
    if (translateComment && originComment !== translateComment) {
      //æ›¿æ¢markdownè¯­æ³•è½¬æ¢ä¸ºHTMLæ ‡ç­¾
      originComment = replaceMarkdownSyntax(originComment)
      body = `    ${DEFAULT_BOT_MESSAGE}
---
${translateComment}
${ORIGIN_CONTENT_PREFIX}${originComment}${ORIGIN_CONTENT_POSTFIX}
${translateOrigin_MD5}`
    }
    await update(octokit, body || undefined, title || undefined)
  } else {
    const needCommitComment =
      translateComment && translateComment !== originComment
    const {
      context: {
        payload: {issue, discussion, pull_request}
      }
    } = github
    translateComment = `
> ${botNote}
----
${
  isModifyTitle === 'false' && needCommitComment
    ? `**Title:** ${translateTitle}`
    : ''
}


${translateComment}`
    if (
      isModifyTitle === 'true' &&
      translateTitle &&
      translateTitle !== originTitle
    ) {
      await update(octokit, undefined, translateTitle)
    }

    if (translateComment && translateComment !== originComment) {
      await createIssueComment({
        pull_number: pull_request?.number,
        discussion_number: discussion?.node_id,
        issue_number: issue?.number,
        body: translateComment,
        octokit
      })
    }
  }

  core.setOutput('complete time', new Date().toTimeString())
}
function replaceMarkdownSyntax(input:string):string {
  // æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…Markdownè¯­æ³•æ ‡è¯†ç¬¦
  const markdownSyntaxRegex = /(\*|_|\`|>|#|\[|\])+/g;
  // æ›¿æ¢å‡½æ•°ï¼Œå°†åŒ¹é…åˆ°çš„Markdownè¯­æ³•æ ‡è¯†ç¬¦æ›¿æ¢ä¸ºHTMLçš„å¯¹åº”æ ‡ç­¾

  const handlePairs = (match:string) => {
    const openingTag = match[1];
    const closingTag = openingTag === '*' ? '</em>' : openingTag === '_' ? '</strong>' : '</code>';
    return `<${openingTag}>${match.substring(2, match.length - 2)}</${closingTag}>`;
  };

  const replaceFunction = (match:string, p1:string) => {

    // æ ¹æ®åŒ¹é…åˆ°çš„å­—ç¬¦ç±»å‹ï¼Œç”Ÿæˆå¯¹åº”çš„HTMLæ ‡ç­¾
    switch (p1) {
      case '*':
        return '<em>';
      case '_':
        return '<strong>';
      case '`':
        return '<code>';
      case '>':
        return '<blockquote>';
      case '#':
        return '<h1>';
      case '[':
        return '<a href="">';
      case ']':
        return '</a>';
      default:
        // // å¦‚æœåŒ¹é…åˆ°çš„å­—ç¬¦æ˜¯æˆå¯¹æ ‡è¯†çš„å¼€å§‹ï¼Œå¤„ç†æˆå¯¹æ ‡è¯†
        if (p1 === '*' || p1 === '_' || p1 === '`') {
          return handlePairs(match);
        }
        return '';
    }
  };
  // ä½¿ç”¨replaceæ–¹æ³•è¿›è¡Œæ›¿æ¢
  return input.replace(markdownSyntaxRegex, replaceFunction);
}

async function run() {
  try {
    await main()
  } catch (err: any) {
    core.setFailed(err.message)
  }
}

run()
